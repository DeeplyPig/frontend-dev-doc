# React基础 #

## React-JSX ##

**所谓的 `JSX` 其实就是 `JavaScript` 对象。**

从`JSX`到页面经历的过程：

![](https://i.imgur.com/dBOd580.png)

**总结：**

1. `JSX` 是 `JavaScript` 语言的一种语法扩展；
2. `React.js` 可以用 `JSX` 来描述你的组件；
3. `JSX` 在编译的时候会变成相应的 `JavaScript` 对象描述；
4. `react-dom` 负责把这个用来描述 `UI` 信息的 `JavaScript` 对象变成 `DOM` 元素，并且渲染到页面上。

## 组件的 `render` 方法 ##

一个组件类必须要实现一个 `render` 方法，这个 `render` 方法必须要返回一个 `JSX` 元素。必须要用一个外层的 `JSX` 元素把所有内容包裹起来，返回并列多个 `JSX` 元素是不合法的。

**表达式插入**

在 `JSX` 当中你可以插入 `JavaScript` 的表达式，表达式返回的结果会相应地渲染到页面上。表达式用 `{}` 包裹。

`{}` 内可以放任何 `JavaScript` 的代码，包括**变量**、**表达式计算**、**函数执行**等。

表达式插入不仅仅可以用在标签内部，也可以用在标签的属性上。

**条件返回**

可以在 `render` 函数内部根据不同条件返回不同的 `JSX`。

**`JSX` 元素变量**

## 组件的组合、嵌套和组件树 ##

**自定义的组件都必须要用大写字母开头，普通的 `HTML` 标签都用小写字母开头。**

## 事件监听 ##

在 `React.js` 不需要手动调用浏览器原生的 `addEventListener` 进行事件监听。`React.js` 帮我们封装好了一系列的 `on*` 的属性，当你需要为某个元素监听某个事件的时候，只需要简单地给它加上 `on*` 就可以了。而且你不需要考虑不同浏览器兼容性的问题，`React.js` 都帮我们封装好这些细节了。

这些事件属性名都必须要用驼峰命名法。

没有经过特殊处理的话，**这些 `on*` 的事件监听只能用在普通的 `HTML` 的标签上，而不能用在组件标签上**。

**`event` 对象**

`React.js` 中的 `event` 对象并不是浏览器提供的，而是它自己内部所构建的。`React.js` 将浏览器原生的 `event` 对象封装了一下，对外提供统一的 `API` 和属性，这样你就不用考虑不同浏览器的兼容性问题。

**关于事件中的 `this`**

    handleClickOnTitle (e) {
        console.log(this) // => null or undefined
    }
   
上面的 `handleClickOnTitle` 中把 `this` 打印出来，你会看到 `this` 是 `null` 或者 `undefined`。

这是因为 `React.js` 调用你所传给它的方法的时候，并不是通过对象方法的方式调用（`this.handleClickOnTitle`），而是直接通过函数调用 （`handleClickOnTitle`），所以事件监听函数内并不能通过 `this` 获取到实例。    

如果你想在事件函数当中使用当前的实例，你需要手动地将实例方法 `bind` 到当前实例上再传入给 `React.js`。

`bind` 会把实例方法绑定到当前实例上，然后我们再把绑定后的函数传给 `React.js` 的 `onClick` 事件监听。

你也可以在 `bind` 的时候给事件监听函数传入一些参数。

这种 `bind` 模式在 `React.js` 的事件监听当中非常常见，`bind` 不仅可以帮我们把事件监听方法中的 `this` 绑定到当前组件实例上；还可以帮助我们在在渲染列表元素的时候，把列表元素传入事件监听函数当中。

## 组件的 `state` 和 `setState` ##

**state**

一个组件的显示形态是可以由它数据状态和配置参数决定的。

**`setState` 接受对象参数**

`setState` 方法由父类 `Component` 所提供。当我们调用这个函数的时候，`React.js` 会更新组件的状态 `state` ，并且重新调用 `render` 方法，然后再把 `render` 方法所渲染的最新的内容显示到页面上。


