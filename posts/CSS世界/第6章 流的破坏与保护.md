# 第6章 流的破坏与保护 #

## 魔鬼属性`float` ##

### `float`的本质与特性 ###

**`float`浮动属性让父元素高度坍塌的原因就是为了实现文字环绕效果**。

`float`自身特性：

- 包裹性；
- 块状化并格式化上下文；
- 破坏文档流；
- 没有任何`margin`合并。

包裹性，由**包裹**和**自适应性**两部分组成。

1. **包裹**。浮动元素父元素宽度`200px`，子元素是一个宽度`128px`宽度的图片，则此时浮动元素宽度表现为**包裹**，就是里面图片的宽度`128px`。

![](https://i.imgur.com/QCNBDxs.jpg)

2. **自适应性**。

**块状化**，元素一旦`float`的属性值不为`none`，则其`display`计算值为`block`或`table`。**`text-align`对浮动元素无效。**

| 设定值 | 计算值 |
| ----- | ------- |
| `inline` | `block` |
| `inline-block` | `block` |
| `inline-table` | `table` |
| `table-row` | `block` |
| `table-row-group` | `block` |
| `table-column` | `block` |
| `table-columngroup` | `block` |
| `table-cell` | `block` |
| `table-caption` | `block` |
| `table-header-group` | `block` |
| `table-footer-group` | `block` |

`float`属性与`display`属性值转换关系

## `float`的作用机制 ##

**文字环绕效果**是由两个特性（**父级高度坍塌**和**行框盒子区域限制**）共同作用的结果，定高只能解决**父级元素高度坍塌**带来的影响，但是对**行框盒子区域限制**没有任何效果，结果导致的问题是浮动元素垂直区域一旦超出高度范围，或下面元素`margin-top`负值上偏移，就很容易使后面的元素发生“环绕效果”。

## `float`更深入的作用机制 ##

**浮动元素和内联元素在一行显示。**

- **浮动锚点**是`float`元素所在的**流**中的一个点，这个点本身并不浮动。其作用是产生**行框盒子**，因为**浮动锚点**表现如同一个空的内联元素，有内联元自然就有**行框盒子**。
- **浮动参考**指的是浮动元素对齐参考的实体。

`float`元素的**浮动参考**是**行框盒子**，也就是`float`元素在当前**行框盒子**内定位。

## `float`与流体布局 ##

<p data-height="265" data-theme-id="0" data-slug-hash="YjrGyL" data-default-tab="css,result" data-user="whjin" data-pen-title="中间内容居中的左中右布局" class="codepen">See the Pen <a href="https://codepen.io/whjin/pen/YjrGyL/">中间内容居中的左中右布局</a> by whjin (<a href="https://codepen.io/whjin">@whjin</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

# `float`的天然克星`clear` #

## 什么是`clear`属性 ##

`clear`专门用来处理`float`属性带来的高度坍塌等问题。

    clear: none | left | right | both
    
- `none`：默认值，左右浮动
- `left`：左侧抗浮动
- `right`：右侧抗浮动
- `both`：两侧抗浮动

实际应用中只使用`clear:both;`即可。

## 成事不足败事有余的`clear` ##

`clear`属性只有块级元素才有效，而`:after`等伪元素默认都是内联水平，这就是伪元素清除浮动影响时需要设置`display`属性值的原因。

`clear:both`的作用本质是让自身不与`float`元素在一行显示，并不是真正意义上的清除浮动。

1. 如果`clear:both;`元素前面的元素就是`float`元素，则`margin-top`负值即使设成`-9999px`，也没有效果。
2. `clear:both;`后面的元素依旧可能发生文字环绕的现象。

# CSS世界的结界——**BFC** #

## **BFC**的定义 ##

**BFC**称为**块级格式化上下文**。**BFC**元素不可能发生`margin`重叠，`margin`重叠会影响外面的元素；**BFC**元素也可以用来清除浮动的影响，如果不清楚，子元素浮动则会父元素高度坍塌，必然会影响后面元素布局和定位。

何时会触发**BFC**，常见情况如下：

- `html`根元素；
- `overflow`的值为`auto`、`scroll`或`hidden`；
- `display`的值为`table-cell`、`table-caption`和`inline-block`中的任何一个；
- `float`的值不为`none`；
- `position`的值不为`relative`和`static`。

只要元素符合上面任意一个条件，就无须使用`clear:both;`属性去清除浮动的影响。

## **BFC**与流体布局 ##

**BFC**的表现原则：具有**BFC**特性的元素的子元素不会受到外部元素的影响，也不会影响外部元素。普通流体元素在设置了`overflow:hidden;`后，会自动填满容器中除了浮动元素以外的剩余空间，形成自适应布局效果。

    img {
        float: left;
        margin-right: 10px;
    }
    
    .content {
        overflow: hidden;
    }
    
基于**BFC**特性的自适应布局有如下优点：

1. 自适应内容由于封闭更加健壮，容错性更强。内部设置`clear:both;`不会与`float`元素相互干扰而导致错位。
2. 自适应内容自动填充浮动以外区域，无需关心浮动元素宽度，可以整站大规模应用。

```
.left {
    float: left;
}

.right {
    float: right;
}

.bfc {
    overflow: hidden;
}
```

1. `float:left;`。浮动元素本身**BFC**化，然而浮动元素具有破坏性和包裹性，失去了元素本身的流体自适应性，因此无法用来实现自动填满容器的自适应布局。
2. `position:absolute;`。脱离文档流，不容易操作。
3. **`overflow:hidden;`块状元素的流体特性保存得很好，加上**BFC**的独立区域特性，而且从IE7开始就支持，兼容性很好。唯一的问题是容器盒子外的元素可能会被隐藏掉。**
4. `display:inline-block;`
5. `display:table-cell`
6. `display:table-row`
7. `display:table-caption`

总结上面的自适应布局设置，最佳实践如下：

1. `overflow: auto/hidden;`，适用于IE7及以上版本浏览器；
2. `display: inline-block;`，适应于IE6和IE7;
3. `display: table-cell;`，适用于IE8及以上版本浏览器。

IE7及以上版本浏览器适配的自适应解决方案：

1. 借助`overflow`属性，如下:
```
.lbf-content {
    overflow: hidden;
}
```
2. 融合`display: table-cell;`和`display: inline-block;`，如下：
```
.lbf-content {
    display: table-cell;
    width: 9999px;
}
```

`display: table-cell;`元素内连续英文字符无法换行的问题：

    .word-break {
        display: table;
        width: 100%;
        table-layout: fixed;
        word-break: break-all;
    }
    
# 最佳结界`overflow` #

